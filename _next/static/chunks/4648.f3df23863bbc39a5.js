(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4648],{49190:function(e,t,r){"use strict";r.d(t,{E:function(){return o},R:function(){return s},S:function(){return l},a:function(){return u}});var i=r(2593),a=r(1604),n=r(26212);let s=a.z.union([a.z.date().transform(e=>i.O$.from(Math.floor(e.getTime()/1e3))),a.z.number().transform(e=>i.O$.from(e))]),l=s.default(new Date(0)),o=s.default(new Date(Date.now()+31536e7));function u(e,t){if(!e)throw new n.x(t);return e}},99756:function(e,t,r){"use strict";r.d(t,{B:function(){return o},C:function(){return h},N:function(){return f},a:function(){return u},s:function(){return c}});var i=r(26212),a=r(1604),n=r(69262);let s=a.z.object({}).catchall(a.z.union([i.cA,a.z.unknown()])),l=a.z.union([a.z.array(s),s]).optional().nullable(),o=a.z.object({name:a.z.union([a.z.string(),a.z.number()]).optional().nullable(),description:a.z.string().nullable().optional().nullable(),image:i.cB.nullable().optional(),animation_url:i.cB.optional().nullable()}),u=o.extend({external_url:i.cB.nullable().optional(),background_color:i.cC.optional().nullable(),properties:l,attributes:l}).catchall(a.z.union([i.cA,a.z.unknown()])),f=a.z.union([u,a.z.string()]),h=u.extend({id:a.z.string(),uri:a.z.string(),image:a.z.string().nullable().optional(),external_url:a.z.string().nullable().optional(),animation_url:a.z.string().nullable().optional()});async function c(e,t,a,s){if((0,n.i)(a))s.value=t;else{let n=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,l=e.getSigner(),o=e.getProvider(),u=new i.cu(l||o,a,n,e.options,e.storage),f=await e.getSignerAddress(),h=e.address,c=await u.read("allowance",[f,h]);return c.lt(t)&&await u.sendTransaction("approve",[h,t]),s}}},84648:function(e,t,r){"use strict";r.d(t,{A:function(){return N},B:function(){return er},C:function(){return ee},D:function(){return Q},E:function(){return L},F:function(){return O},H:function(){return X},I:function(){return et},M:function(){return ec},S:function(){return ei},a:function(){return M},f:function(){return I},k:function(){return ea},o:function(){return eo},p:function(){return eu},q:function(){return ef},r:function(){return eh},s:function(){return em},t:function(){return ed},u:function(){return ep},v:function(){return K},w:function(){return R},x:function(){return F},y:function(){return z},z:function(){return D}});var i,a,n=r(21046),s=r(61744),l=r(31886),o=r(9279),u=r(38197),f=r(2593),h=r(16441),c=r(29251),m=r(26212),d=r(69262),p=r(28854),y=r(48764),g=r(56351),b=r.n(g),w=r(99269);class v{print(){v.print(this)}bufferIndexOf(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(r)return this.binarySearch(e,t,y.Buffer.compare);let i=(e,t)=>e.equals(t);return this.linearSearch(e,t,i)}static binarySearch(e,t,r){let i=0,a=e.length-1;for(;i<=a;){let n=Math.floor((i+a)/2),s=r(e[n],t);if(0===s){for(let i=n-1;i>=0;i--)if(0!==r(e[i],t))return i+1;return 0}s<0?i=n+1:a=n-1}return -1}binarySearch(e,t,r){return v.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let i=0;i<e.length;i++)if(r(e[i],t))return i;return -1}linearSearch(e,t,r){return v.linearSearch(e,t,r)}static bufferify(e){if(!y.Buffer.isBuffer(e)){if("object"==typeof e&&e.words)return y.Buffer.from(e.toString(S),"hex");if(v.isHexString(e))return y.Buffer.from(e.replace(/^0x/,""),"hex");if("string"==typeof e)return y.Buffer.from(e);if("bigint"==typeof e)return y.Buffer.from(e.toString(16),"hex");else if(e instanceof Uint8Array)return y.Buffer.from(e.buffer);else if("number"==typeof e){let t=e.toString();return t.length%2&&(t=`0${t}`),y.Buffer.from(t,"hex")}else if(ArrayBuffer.isView(e))return y.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return v.bigNumberify(e)}static bigNumberify(e){if("bigint"==typeof e)return e;if("string"==typeof e)return e.startsWith("0x")&&v.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(y.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){let t=Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join("");return BigInt(`0x${t}`)}(e);if("number"==typeof e)return BigInt(e);throw Error("cannot bigNumberify")}static isHexString(e){return"string"==typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return v.bufferToHex(e,t)}static bufferToHex(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return`${t?"0x":""}${(e||y.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return v.bufferify(e)}bufferifyFn(e){return t=>{let r=e(t);if(y.Buffer.isBuffer(r))return r;if(this.isHexString(r))return y.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return y.Buffer.from(r);if("bigint"==typeof r)return y.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return y.Buffer.from(r.buffer,r.byteOffset,r.byteLength);let i=function(e){let t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex")),a=e(i),n=function(e){let t=new Uint8Array(e);return Array.from(t).map(e=>e.toString(16).padStart(2,"0")).join("")}(a);return y.Buffer.from(n,"hex")}}isHexString(e){return v.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map((e,r)=>[e,t[r]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var x=v;function S(e){let t=e.words,r=new ArrayBuffer(4*t.length),i=new Uint8Array(r);for(let e=0;e<t.length;e++)i[4*e]=t[e]>>24&255,i[4*e+1]=t[e]>>16&255,i[4*e+2]=t[e]>>8&255,i[4*e+3]=255&t[e];return r}class T extends x{duplicateOdd=!1;concatenator=y.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash){if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else if(y.Buffer.isBuffer(r.fillDefaultHash)||"string"==typeof r.fillDefaultHash)this.fillDefaultHash=(e,t)=>r.fillDefaultHash;else throw Error('method "fillDefaultHash" must be a function, Buffer, or string')}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(y.Buffer.compare)),this.fillDefaultHash)for(let e=this.leaves.length;e<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));e++)this.leaves.push(this.bufferify(this.fillDefaultHash(e,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){let t=this.layers.length;this.layers.push([]);let r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let i=0;i<e.length;i+=2){if(i>=r){this.layers[t].push(...e.slice(r));break}if(i+1===e.length&&e.length%2==1){let r=e[e.length-1],a=r;if(this.isBitcoinTree){a=this.hashFn(this.concatenator([b()(r),b()(r)])),a=b()(this.hashFn(a)),this.layers[t].push(a);continue}if(this.duplicateOdd);else{this.layers[t].push(e[i]);continue}}let a=e[i],n=i+1===e.length?a:e[i+1],s=null;s=this.isBitcoinTree?[b()(a),b()(n)]:[a,n],this.sortPairs&&s.sort(y.Buffer.compare);let l=this.hashFn(this.concatenator(s));this.isBitcoinTree&&(l=b()(this.hashFn(l))),this.layers[t].push(l)}e=this.layers[t]}}addLeaf(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(y.Buffer.compare))),this.leaves.filter(t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?y.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);let t=this.getLeaves();for(let r=0;r<t.length;r++){let i=t[r];if(i.equals(e))return r}return -1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(e=>T.bufferToHex(e)),null,2)}static unmarshalLeaves(e){let t=null;if("string"==typeof e)t=JSON.parse(e);else if(e instanceof Object)t=e;else throw Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw Error("Expected JSON string to be array");return t.map(T.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(e))):e.push(t),e),[])}getLayersFlat(){let e=this.layers.reduce((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e),[]);return e.unshift(y.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?y.Buffer.from([]):this.layers[this.layers.length-1][0]||y.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(void 0===e)throw Error("leaf is required");e=this.bufferify(e);let r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===y.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let e=0;e<this.layers.length;e++){let i=this.layers[e],a=t%2,n=a?t-1:this.isBitcoinTree&&t===i.length-1&&e<this.layers.length-1?t:t+1;n<i.length&&r.push({position:a?"left":"right",data:i[n]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(e=>this.bufferToHex(e.data))}getProofs(){let e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,i){let a=t%2;if(-1===e){a||i.push([...r].reverse());return}if(t>=this.layers[e].length)return;let n=this.layers[e],s=a?t-1:t+1,l=!1;s<n.length&&(l=!0,r.push({position:a?"left":"right",data:n[s]})),this.getProofsDFS(e-1,2*t,r,i),this.getProofsDFS(e-1,2*t+1,r,i),l&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(e=>["left"===e.position?0:1,this.bufferToHex(e.data)])}getProofIndices(e,t){let r=2**t,i=new Set;for(let t of e){let e=r+t;for(;e>1;)i.add(1^e),e=e/2|0}let a=e.map(e=>r+e),n=Array.from(i).sort((e,t)=>e-t).reverse();i=a.concat(n);let s=new Set,l=[];for(let e of i)if(!s.has(e))for(l.push(e);e>1&&(s.add(e),s.has(1^e));)e=e/2|0;return l.filter(t=>!e.includes(t-r))}getProofIndicesForUnevenTree(e,t){let r=Math.ceil(Math.log2(t)),i=[];for(let e=0;e<r;e++){let r=t%2!=0;r&&i.push({index:e,leavesCount:t}),t=Math.ceil(t/2)}let a=[],n=e;for(let e=0;e<r;e++){let t=n.map(e=>e%2==0?e+1:e-1),r=t.filter(e=>!n.includes(e)),s=i.find(t=>{let{index:r}=t;return r===e});s&&n.includes(s.leavesCount-1)&&(r=r.slice(0,-1)),a.push(r),n=[...new Set(n.map(e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2))]}return a}getMultiProof(e,t){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat());let r=this.isUnevenTree();if(r&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(y.Buffer.compare));let r=e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1);if(!r.every(e=>-1!==e))throw Error("Element does not exist in Merkle tree");let i=[],a=[],n=[];for(let e=0;e<this.layers.length;e++){let t=this.layers[e];for(let e=0;e<r.length;e++){let s=r[e],l=this.getPairNode(t,s);i.push(t[s]),l&&a.push(l),n.push(s/2|0)}r=n.filter((e,t,r)=>r.indexOf(e)===t),n=[]}return a.filter(e=>!i.includes(e))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(t=>e[t])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],i=t;for(let t of e){let e=[];for(let r of i){if(r%2==0){let a=r+1;if(!i.includes(a)&&t[a]){e.push(t[a]);continue}}let a=r-1;if(!i.includes(a)&&t[a]){e.push(t[a]);continue}}r=r.concat(e);let a=new Set;for(let e of i){if(e%2==0){a.add(e/2);continue}if(e%2==0){a.add((e+1)/2);continue}a.add((e-1)/2)}i=Array.from(a)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(e=>this.bufferToHex(e))}getProofFlags(e,t){let r;if(!Array.isArray(e)||e.length<=0)throw Error("Invalid Inputs!");if(!(r=e.every(Number.isInteger)?[...e].sort((e,t)=>e===t?0:e>t?1:-1):e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1)).every(e=>-1!==e))throw Error("Element does not exist in Merkle tree");let i=t.map(e=>this.bufferify(e)),a=[],n=[];for(let e=0;e<this.layers.length;e++){let t=this.layers[e];r=r.reduce((e,r)=>{let s=a.includes(t[r]);if(!s){let e=this.getPairNode(t,r),s=i.includes(t[r])||i.includes(e);e&&n.push(!s),a.push(t[r]),a.push(e)}return e.push(r/2|0),e},[])}return n}verify(e,t,r){let i=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let t=0;t<e.length;t++){let r=e[t],a=null,n=null;if("string"==typeof r)a=this.bufferify(r),n=!0;else if(Array.isArray(r))n=0===r[0],a=this.bufferify(r[1]);else if(y.Buffer.isBuffer(r))a=r,n=!0;else if(r instanceof Object)a=this.bufferify(r.data),n="left"===r.position;else throw Error("Expected node to be of type string or object");let s=[];this.isBitcoinTree?(s.push(b()(i)),s[n?"unshift":"push"](b()(a)),i=this.hashFn(this.concatenator(s)),i=b()(this.hashFn(i))):this.sortPairs?-1===y.Buffer.compare(i,a)?(s.push(i,a),i=this.hashFn(this.concatenator(s))):(s.push(a,i),i=this.hashFn(this.concatenator(s))):(s.push(i),s[n?"unshift":"push"](a),i=this.hashFn(this.concatenator(s)))}return 0===y.Buffer.compare(i,r)}verifyMultiProof(e,t,r,i,a){let n=this.isUnevenTree();if(n)return this.verifyMultiProofForUnevenTree(e,t,r,i,a);let s=Math.ceil(Math.log2(i));e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),a=a.map(e=>this.bufferify(e));let l={};for(let[e,i]of this.zip(t,r))l[2**s+e]=i;for(let[e,r]of this.zip(this.getProofIndices(t,s),a))l[e]=r;let o=Object.keys(l).map(e=>Number(e)).sort((e,t)=>e-t);o=o.slice(0,o.length-1);let u=0;for(;u<o.length;){let e=o[u];if(e>=2&&({}).hasOwnProperty.call(l,1^e)){let t=[l[e-e%2],l[e-e%2+1]];this.sortPairs&&(t=t.sort(y.Buffer.compare));let r=t[1]?this.hashFn(this.concatenator(t)):t[0];l[e/2|0]=r,o.push(e/2|0)}u+=1}return!t.length||({}).hasOwnProperty.call(l,1)&&l[1].equals(e)}verifyMultiProofWithFlags(e,t,r,i){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);let a=t.length,n=i.length,s=[],l=0,o=0,u=0;for(let e=0;e<n;e++){let n=i[e]?l<a?t[l++]:s[o++]:r[u++],f=l<a?t[l++]:s[o++],h=[n,f].sort(y.Buffer.compare);s[e]=this.hashFn(this.concatenator(h))}return 0===y.Buffer.compare(s[n-1],e)}verifyMultiProofForUnevenTree(e,t,r,i,a){e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),a=a.map(e=>this.bufferify(e));let n=this.calculateRootForUnevenTree(t,r,i,a);return e.equals(n)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){let e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(e,!1))),t=[];for(let r=0;r<e.length;r++){let i=[];for(let a=0;a<e[r].length;a++){let n={[e[r][a]]:null};if(t.length){n[e[r][a]]={};let i=t.shift(),s=Object.keys(i)[0];if(n[e[r][a]][s]=i[s],t.length){let i=t.shift(),s=Object.keys(i)[0];n[e[r][a]][s]=i[s]}}i.push(n)}t.push(...i)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){let r=t%2==0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){let e=this.getLayersAsObject();return(0,w.asTree)(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){let t=e?.length||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,i){let a=this.zip(e,t).sort((e,t)=>{let[r]=e,[i]=t;return r-i}),n=a.map(e=>{let[t]=e;return t}),s=this.getProofIndicesForUnevenTree(n,r),l=0,o=[];for(let e=0;e<s.length;e++){let t=s[e],r=l;l+=t.length,o[e]=this.zip(t,i.slice(r,l))}let u=[a];for(let e=0;e<o.length;e++){let t=o[e].concat(u[e]).sort((e,t)=>{let[r]=e,[i]=t;return r-i}).map(e=>{let[,t]=e;return t}),r=u[e].map(e=>{let[t]=e;return t}),i=[...new Set(r.map(e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2))],a=[];for(let e=0;e<i.length;e++){let r=i[e],n=t[2*e],s=t[2*e+1],l=s?this.hashFn(this.concatenator([n,s])):n;a.push([r,l])}u.push(a)}return u[u.length-1][0][1]}}var P=r(49190),k=r(1604),B=r(99756),C=r(57632),A=r(48764).Buffer;function L(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function O(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function z(e,t){return"unlimited"===e?n.Bz:s.parseUnits(e,t)}async function H(e){let t=Array.from({length:Math.ceil(e.length/25e3)},(t,r)=>e.slice(25e3*r,25e3*r+25e3)),r=[],i=await Promise.all(t.map(e=>m.bO.parseAsync(e)));for(let e of i)r.push(...e);return r}let N=((i={})[i.V1=1]="V1",i[i.V2=2]="V2",i);class E{constructor(e,t,r,i,a){this.storage=e,this.shardNybbles=i,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=a,this.shards={},this.trees={}}static async fromUri(e,t){try{let r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return E.fromShardedMerkleTreeInfo(r,t)}catch(e){return}}static async fromShardedMerkleTreeInfo(e,t){return new E(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,i){switch(i){case N.V1:return l.keccak256(["address","uint256"],[e.address,z(e.maxClaimable,t)]);case N.V2:return l.keccak256(["address","uint256","uint256","address"],[e.address,z(e.maxClaimable,t),z(e.price||"unlimited",r),e.currencyAddress||o.d])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let i=e[r];if(void 0===i){let a=await (0,d.f)(t,r);i=a.decimals,e[r]=i}return i}static async buildAndUpload(e,t,r,i,a){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2,s=await H(e),l={};for(let e of s){let t=e.address.slice(2,2+n).toLowerCase();void 0===l[t]&&(l[t]=[]),l[t].push(e)}let o={},f=await Promise.all(Object.entries(l).map(async e=>{let[i,n]=e;return[i,new T(await Promise.all(n.map(async e=>{let i=await E.fetchAndCacheDecimals(o,r,e.currencyAddress);return E.hashEntry(e,t,i,a)})),u.keccak256,{sort:!0}).getHexRoot()]})),h=Object.fromEntries(f),c=new T(Object.values(h),u.keccak256,{sort:!0}),m=[];for(let[e,t]of Object.entries(l)){let r={proofs:c.getProof(h[e]).map(e=>"0x"+e.data.toString("hex")),entries:t};m.push({data:JSON.stringify(r),name:`${e}.json`})}let d=await i.uploadBatch(m),p=d[0].slice(0,d[0].lastIndexOf("/")),y=await i.upload(s),g={merkleRoot:c.getHexRoot(),baseUri:p,originalEntriesUri:y,shardNybbles:n,tokenDecimals:t,isShardedMerkleTree:!0},b=await i.upload(g);return{shardedMerkleInfo:g,uri:b}}async getProof(e,t,r){let i=e.slice(2,2+this.shardNybbles).toLowerCase(),a=this.shards[i],n={};if(void 0===a)try{let e=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;a=this.shards[i]=await this.storage.downloadJSON(`${e}${i}.json`);let s=await Promise.all(a.entries.map(async e=>{let i=await E.fetchAndCacheDecimals(n,t,e.currencyAddress);return E.hashEntry(e,this.tokenDecimals,i,r)}));this.trees[i]=new T(s,u.keccak256,{sort:!0})}catch(e){return null}let s=a.entries.find(t=>t.address.toLowerCase()===e.toLowerCase());if(!s)return null;let l=await E.fetchAndCacheDecimals(n,t,s.currencyAddress),o=E.hashEntry(s,this.tokenDecimals,l,r),f=this.trees[i].getProof(o).map(e=>"0x"+e.data.toString("hex"));return m.bP.parseAsync({...s,proof:f.concat(a.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}}async function I(e,t,r,i,a,n){if(!r)return null;let s=r[t];if(s){let r=await a.downloadJSON(s);if(r.isShardedMerkleTree&&r.merkleRoot===t){let t=await E.fromShardedMerkleTreeInfo(r,a);return await t.getProof(e,i,n)}let l=await m.bQ.parseAsync(r);if(t===l.merkleRoot)return l.claims.find(t=>t.address.toLowerCase()===e.toLowerCase())||null}return null}function R(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function F(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function M(e,t,i,a,n){let l=e.getSigner(),o=e.getProvider(),u=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,h=new m.cu(l||o,t,u,e.options,e.storage),c=await e.getSignerAddress(),d=e.address,p=await h.read("allowance",[c,d]),y=f.O$.from(i).mul(f.O$.from(a)).div(s.parseUnits("1",n));p.lt(y)&&await h.sendTransaction("approve",[d,p.add(y)])}async function D(e,t,r,i,a,l,u,c,m){let y=z(r.maxClaimablePerWallet,a),g=[h.hexZeroPad([0],32)],b=r.price,w=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(o.d)){let t=await I(e,r.merkleRootHash.toString(),await i(),l.getProvider(),u,m);if(t)g=t.proof,y="unlimited"===t.maxClaimable?n.Bz:s.parseUnits(t.maxClaimable,a),b=void 0===t.price||"unlimited"===t.price?n.Bz:await (0,p.n)(l.getProvider(),t.price,t.currencyAddress||o.d),w=t.currencyAddress||o.d;else if(m===N.V1)throw Error("No claim found for this address")}}catch(e){if(e?.message==="No claim found for this address")throw e;console.warn("failed to check claim condition merkle root hash, continuing anyways",e)}let v=await l.getCallOverrides()||{},x=b.toString()!==n.Bz.toString()?b:r.price,S=w!==o.d?w:r.currencyAddress;return x.gt(0)&&((0,d.i)(S)?v.value=f.O$.from(x).mul(t).div(s.parseUnits("1",a)):c&&await M(l,S,x,t,a)),{overrides:v,proofs:g,maxClaimable:y,price:x,currencyAddress:S,priceInProof:b,currencyAddressInProof:w}}let U=k.z.object({name:k.z.string(),symbol:k.z.string(),decimals:k.z.number()}),j=U.extend({value:m.b9,displayValue:k.z.string()}),$=k.z.object({name:k.z.string().optional()}).catchall(k.z.unknown()),q=k.z.object({startTime:P.S,currencyAddress:k.z.string().default(m.aZ),price:m.cz.default(0),maxClaimableSupply:m.cD,maxClaimablePerWallet:m.cD,waitInSeconds:m.ba.default(0),merkleRootHash:m.cE.default(h.hexZeroPad([0],32)),snapshot:k.z.optional(m.bO).nullable(),metadata:$.optional()}),W=k.z.array(q),V=q.extend({availableSupply:m.cD,currentMintSupply:m.cD,currencyMetadata:j.default({value:f.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:m.b9,waitInSeconds:m.b9,startTime:m.b9.transform(e=>new Date(1e3*e.toNumber())),snapshot:m.bO.optional().nullable()});async function J(e,t,r,i,a){let n=await H(e),s=n.map(e=>e.address),l=new Set(s).size<s.length;if(l)throw new m.s;let o=await E.buildAndUpload(n,t,r,i,a);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}async function _(e,t,r,i,a){let n=[],s=await Promise.all(e.map(async e=>{if(e.snapshot&&e.snapshot.length>0){let s=await J(e.snapshot,t,r,i,a);n.push(s),e.merkleRootHash=s.merkleRoot}else e.merkleRootHash=h.hexZeroPad([0],32);return e}));return{inputsWithSnapshots:s,snapshotInfos:n}}async function Z(e,t,r,i){let a;let n=e.currencyAddress===o.d?m.aZ:e.currencyAddress,s=z(e.maxClaimableSupply,t),l=z(e.maxClaimablePerWallet,t);return e.metadata&&(a="string"==typeof e.metadata?e.metadata:await i.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:l,pricePerToken:await (0,p.n)(r,e.price,n),currency:n,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:a}}async function Q(e,t,r,i,a){let{inputsWithSnapshots:n,snapshotInfos:s}=await _(e,t,r,i,a),l=await W.parseAsync(n),o=(await Promise.all(l.map(e=>Z(e,t,r,i)))).sort((e,t)=>(function(e,t){let r=f.O$.from(e),i=f.O$.from(t);return r.eq(i)?0:r.gt(i)?1:-1})(e.startTimestamp,t.startTimestamp));return{snapshotInfos:s,sortedConditions:o}}async function Y(e,t,r){if(!t)return null;let i=t[e];if(i){let t=await r.downloadJSON(i);if(t.isShardedMerkleTree&&t.merkleRoot===e){let e=await E.fromUri(i,r);return e?.getAllEntries()||null}{let r=await m.bQ.parseAsync(t);if(e===r.merkleRoot)return r.claims.map(e=>({address:e.address,maxClaimable:e.maxClaimable,price:e.price,currencyAddress:e.currencyAddress}))}}return null}function G(e,t){return e.toString()===n.Bz.toString()?"unlimited":s.formatUnits(e,t)}async function K(e,t,r,i,a,n){let s;let l=await (0,d.a)(r,e.currency,e.pricePerToken),o=G(e.maxClaimableSupply,t),u=G(e.maxClaimablePerWallet,t),h=G(f.O$.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),c=G(e.supplyClaimed,t);return e.metadata&&(s=await a.downloadJSON(e.metadata)),V.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:u,currentMintSupply:c,availableSupply:h,waitInSeconds:e.waitTimeInSecondsBetweenClaims?.toString(),price:f.O$.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:l,merkleRootHash:e.merkleRoot,snapshot:n?await Y(e.merkleRoot,i,a):void 0,metadata:s})}async function X(e,t,r){if(e>=r.length)throw Error(`Index out of bounds - got index: ${e} with ${r.length} conditions`);let i=r[e].currencyMetadata.decimals,a=r[e].price,n=s.formatUnits(a,i),l=await q.parseAsync({...r[e],price:n,...t}),o=await V.parseAsync({...l,price:a});return r.map((t,r)=>{let a;a=r===e?o:t;let n=s.formatUnits(a.price,i);return{...a,price:n}})}let ee=((a={}).NotEnoughSupply="There is not enough supply to claim.",a.AddressNotAllowed="This address is not on the allowlist.",a.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",a.ClaimPhaseNotStarted="Claim phase has not started yet.",a.AlreadyClaimed="You have already claimed the token.",a.WrongPriceOrCurrency="Incorrect price or currency.",a.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",a.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",a.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",a.NoClaimConditionSet="There is no claim condition set.",a.NoWallet="No wallet connected.",a.Unknown="No claim conditions found.",a);function et(e){if(void 0!==e)return h.hexlify(e);{let e=A.alloc(16);return(0,C.Z)({},e),h.hexlify(c.Y0(e.toString("hex")))}}let er=k.z.object({to:m.bd.refine(e=>e.toLowerCase()!==o.d,{message:"Cannot create payload to mint to zero address"}),price:m.cz.default(0),currencyAddress:m.bc.default(m.aZ),mintStartTime:P.S,mintEndTime:P.E,uid:k.z.string().optional().transform(e=>et(e)),primarySaleRecipient:m.bd.default(o.d)}),ei=er.extend({quantity:m.cz}),ea=ei.extend({mintStartTime:m.b9,mintEndTime:m.b9}),en=er.extend({metadata:B.N,royaltyRecipient:k.z.string().default(o.d),royaltyBps:m.cF.default(0)}),es=en.extend({metadata:B.N.default(""),uri:k.z.string(),royaltyBps:m.b9,mintStartTime:m.b9,mintEndTime:m.b9}),el=en.extend({metadata:B.N.default(""),quantity:m.ba}),eo=el.extend({tokenId:m.ba}),eu=es.extend({tokenId:m.b9,quantity:m.b9}),ef=en.extend({metadata:B.N.default(""),quantity:m.b9.default(1)}),eh=es.extend({quantity:m.b9.default(1)}),ec=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],em=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ed=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ep=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},56351:function(e,t,r){var i=r(48764).Buffer;e.exports=function(e){for(var t=new i(e.length),r=0,a=e.length-1;r<=a;++r,--a)t[r]=e[a],t[a]=e[r];return t}},99269:function(e){e.exports=function(){function e(t,r,i,a,n,s,l){var o,u,f,h="",c=0,m=a.slice(0);if(m.push([r,i])&&a.length>0&&(a.forEach(function(e,t){t>0&&(h+=(e[1]?" ":"│")+"  "),f||e[0]!==r||(f=!0)}),h+=(o=i?"└":"├",t?o+="─ ":o+="──┐",o+t),n&&("object"!=typeof r||r instanceof Date)&&(h+=": "+r),f&&(h+=" (circular ref.)"),l(h)),!f&&"object"==typeof r){var d=function(e,t){var r=[];for(var i in e)e.hasOwnProperty(i)&&(!t||"function"!=typeof e[i])&&r.push(i);return r}(r,s);d.forEach(function(t){u=++c===d.length,e(t,r[t],u,m,n,s,l)})}}var t={};return t.asLines=function(t,r,i,a){e(".",t,!1,[],r,"function"!=typeof i&&i,a||i)},t.asTree=function(t,r,i){var a="";return e(".",t,!1,[],r,i,function(e){a+=e+"\n"}),a},t}()}}]);