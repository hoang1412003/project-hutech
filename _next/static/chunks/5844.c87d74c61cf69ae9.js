"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5844],{32252:function(t,e,i){i.d(e,{g:function(){return a},i:function(){return s}});var n=i(22555);function s(t){let e=new URL(t).hostname;return e.endsWith(".thirdweb.com")||"localhost"===e||"0.0.0.0"===e}function a(t){return(0,n.OZ$)(t).map(t=>{try{let e=new URL(t);return e.hostname.endsWith(".thirdweb.com")&&(e.pathname="",e.search=""),e.toString()}catch(e){return t}})}},35844:function(t,e,i){i.r(e),i.d(e,{BloctoConnector:function(){return C}});var n=i(71958),s=i(16074),a=i(42009),h=i(83287),r=i(89432),o=i(40562),c=i(19485),d=i(241),u=i(16441),l=i(64829),w=i(32252),g=i(59014);i(54146);var p=new WeakMap,f=new WeakMap,m=new WeakMap,v=new WeakMap,b=new WeakSet,_=new WeakSet;class C extends h.W{constructor(t){let{chains:e,options:i={}}=t;super({chains:e,options:i}),(0,n._)(this,_),(0,n._)(this,b),(0,a._)(this,"id",l.w.blocto),(0,a._)(this,"name","Blocto"),(0,a._)(this,"ready",!0),(0,s._)(this,p,{writable:!0,value:void 0}),(0,s._)(this,f,{writable:!0,value:void 0}),(0,s._)(this,m,{writable:!0,value:void 0}),(0,s._)(this,v,{writable:!0,value:void 0}),(0,s.a)(this,f,this.onAccountsChanged.bind(this)),(0,s.a)(this,m,this.onChainChanged.bind(this)),(0,s.a)(this,v,this.onDisconnect.bind(this))}async connect(t){try{let e=await this.getProvider(t);this.setupListeners(),this.emit("message",{type:"connecting"});let i=await e.request({method:"eth_requestAccounts"}),n=c.getAddress(i[0]),s=await this.getChainId(),a=this.isChainUnsupported(s);return{account:n,chain:{id:s,unsupported:a},provider:e}}catch(t){if((0,n.a)(this,_,I).call(this),(0,n.a)(this,b,y).call(this,t))throw new r.U(t);throw t}}async disconnect(){let t=await this.getProvider();await t.request({method:"wallet_disconnect"}),this.removeListeners(),(0,n.a)(this,_,I).call(this)}async getAccount(){let t=await this.getProvider(),e=await t.request({method:"eth_accounts"}),[i]=e||[];if(!i)throw Error("No accounts found");return i}async getChainId(){let t=await this.getProvider(),e=await t.request({method:"eth_chainId"});return(0,g.n)(e)}getProvider(){let{chainId:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!(0,s.b)(this,p)){let e=t??this.options.chainId??this.chains[0]?.chainId??1,i=this.chains.find(t=>t.chainId===e)?.rpc[0];(0,s.a)(this,p,new o.Z({ethereum:{chainId:e,rpc:i},appId:this.options.appId})?.ethereum)}if(!(0,s.b)(this,p))throw new r.a;return Promise.resolve((0,s.b)(this,p))}async getSigner(){let{chainId:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},[e,i]=await Promise.all([this.getProvider(),this.getAccount()]);return new d.Q(e,t).getSigner(i)}async isAuthorized(){return!!s.b(this,p)?._blocto?.sessionKey??!1}async switchChain(t){let e=await this.getProvider(),i=u.hexValue(t),s=this.chains.find(e=>e.chainId===t);if(!s)throw new r.S(Error("chain not found on connector."));let a=e._blocto.supportNetworkList[`${t}`];if(!a)throw new r.S(Error(`Blocto unsupported chain: ${i}`));try{return await e.request({method:"wallet_addEthereumChain",params:[{chainId:i,rpcUrls:(0,w.g)(s)}]}),await e.request({method:"wallet_switchEthereumChain",params:[{chainId:i}]}),s}catch(t){if((0,n.a)(this,b,y).call(this,t))throw new r.U(t);throw new r.S(t)}}onAccountsChanged(){}async onChainChanged(t){let e=(0,g.n)(t),i=this.isChainUnsupported(e),n=await this.getAccount();this.emit("change",{chain:{id:e,unsupported:i},account:n})}onDisconnect(){this.emit("disconnect")}async setupListeners(){let t=await this.getProvider();t.on("accountsChanged",(0,s.b)(this,f)),t.on("chainChanged",(0,s.b)(this,m)),t.on("disconnect",(0,s.b)(this,v))}async removeListeners(){let t=await this.getProvider();t.off("accountsChanged",(0,s.b)(this,f)),t.off("chainChanged",(0,s.b)(this,m)),t.off("disconnect",(0,s.b)(this,v))}}function y(t){return/(user rejected)/i.test(t.message)}function I(){(0,s.a)(this,p,void 0)}}}]);